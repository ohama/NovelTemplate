---
phase: 04-quality-checks
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - claude_src/novel/agents/tension-monitor.md
  - claude_src/novel/commands/check.md
  - .claude/commands/novel/check.md
autonomous: false

must_haves:
  truths:
    - "Tension monitor detects scenes with no apparent conflict"
    - "Tension monitor tracks tension curve across scenes"
    - "/novel:check spawns all five checkers in parallel"
    - "/novel:check consolidates results into unified report"
    - "Check reports are saved to check_reports/ directory"
    - "User can run /novel:check and see quality issues sorted by severity"
  artifacts:
    - path: "claude_src/novel/agents/tension-monitor.md"
      provides: "Tension and conflict monitoring agent"
      min_lines: 200
      contains: "role.*execution.*validation"
    - path: "claude_src/novel/commands/check.md"
      provides: "/novel:check command definition"
      min_lines: 200
      contains: "execution.*error_handling"
    - path: ".claude/commands/novel/check.md"
      provides: "Symlink for command discoverability"
  key_links:
    - from: "tension-monitor agent"
      to: "beats/outline.md"
      via: "load expected tension curve"
      pattern: "beats/outline"
    - from: "tension-monitor agent"
      to: "draft/scenes/*.md"
      via: "analyze conflict markers"
      pattern: "draft/scenes"
    - from: "/novel:check command"
      to: "canon-checker agent"
      via: "spawn parallel"
      pattern: "canon-checker"
    - from: "/novel:check command"
      to: "timeline-keeper agent"
      via: "spawn parallel"
      pattern: "timeline-keeper"
    - from: "/novel:check command"
      to: "voice-coach agent"
      via: "spawn parallel"
      pattern: "voice-coach"
    - from: "/novel:check command"
      to: "pacing-analyzer agent"
      via: "spawn parallel"
      pattern: "pacing-analyzer"
    - from: "/novel:check command"
      to: "tension-monitor agent"
      via: "spawn parallel"
      pattern: "tension-monitor"
---

<objective>
Build the novel-tension-monitor agent and create the /novel:check command that orchestrates all five quality checkers in parallel and generates a unified quality report.

Purpose: This plan completes the quality checking pipeline. Tension monitor ensures every scene has conflict and stakes, tracking the narrative tension curve across the story. The /novel:check command brings all checkers together, spawning them in parallel for efficiency and consolidating their outputs into an actionable quality report.

Output: Tension monitor agent definition, /novel:check command definition, and command symlink for discoverability.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-quality-checks/04-RESEARCH.md
@.planning/phases/04-quality-checks/04-01-SUMMARY.md
@.planning/phases/04-quality-checks/04-02-SUMMARY.md

# Checker agents built in previous plans
@claude_src/novel/agents/canon-checker.md
@claude_src/novel/agents/timeline-keeper.md
@claude_src/novel/agents/voice-coach.md
@claude_src/novel/agents/pacing-analyzer.md

# Existing command patterns
@claude_src/novel/commands/write.md
@claude_src/novel/commands/outline.md
@claude_src/novel/commands/status.md

# Skills and utilities
@claude_src/novel/utils/state-manager.md
@claude_src/novel/skills/git-integration.md

# Schemas for reference
@claude_src/novel/schemas/story_state.schema.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tension-monitor agent definition</name>
  <files>claude_src/novel/agents/tension-monitor.md</files>
  <action>
Create novel-tension-monitor agent following the established agent pattern.

**Agent structure:**

1. **Frontmatter** (YAML):
   - name: tension-monitor
   - description: Monitor conflict presence, stakes, and tension curve across scenes
   - allowed-tools: [Read, Glob, Grep]
   - version: 1.0

2. **Purpose section**:
   - Inputs: beats/outline.md (expected arc), beats/scenes/*.md (beat tension expectations), draft/scenes/*.md (prose), state/story_state.json (scene progression)
   - Outputs: JSON with issues array and summary
   - Role: Ensure every scene has conflict, track tension curve, identify flat spots

3. **Role section** (in XML tags):
   - Job: Analyze prose for conflict markers, track tension levels, compare to expected arc
   - What you check:
     - Conflict present in each scene (opposition to character goal)
     - Stakes are clear (what's at risk?)
     - Tension rises appropriately toward midpoint and climax
     - Tension releases appropriately after peaks
     - No extended flat sections (3+ consecutive low-tension scenes)
     - Scene goals are challenged (not achieved without opposition)
   - Principles:
     - MAJOR severity for scenes with no apparent conflict
     - MAJOR severity for 3+ consecutive flat tension scenes
     - MINOR severity for tension curve slightly off expected arc
     - Tension is subjective - flag absence, not degree
     - Resolution scenes should have tension release (not always high)

4. **Execution section** with 4 steps:

   **Step 1: Load Tension Expectations**
   - Read beats/outline.md:
     - Extract Save the Cat beat markers with expected tension levels:
       - Opening Image: Low-Medium (establish normal world)
       - Catalyst: Rising (inciting incident)
       - Midpoint: High (stakes raise)
       - All Is Lost: Peak (lowest emotional point for protagonist)
       - Finale: Building to Peak
       - Final Image: Resolution (release)
   - Read beats/scenes/*.md files:
     - Extract beat_type or tension hints from beat specifications
     - Map scene_id to expected_tension_level
   - Build expectations: { scene_id: { beat_type, expected_tension: "low|medium|high|peak|release" } }

   **Step 2: Analyze Scene Tension**
   - For each draft scene:
     - Read scene content
     - Identify conflict markers:
       - Opposition: Character wants X, something/someone prevents it
       - Stakes: What happens if character fails?
       - Obstacles: Physical, emotional, or interpersonal barriers
       - Tension words: danger, fear, urgent, risk, threat, worried, afraid
       - Dialogue conflict: disagreement, refusal, confrontation
     - Calculate tension_score: Count of conflict markers / scene length (normalized)
     - Classify: low (<0.3), medium (0.3-0.6), high (0.6-0.8), peak (>0.8)
     - Compare to expected_tension from Step 1
   - Build actual_tension map: { scene_id: { actual_tension, markers_found } }

   **Step 3: Track Tension Curve**
   - Build tension curve array: [{ scene_id, chapter, scene, actual_tension }]
   - Sort by chapter, then scene (chronological order)
   - Check for issues:
     a. **No conflict scenes:**
        - If markers_found == 0 or tension_score very low:
          - MAJOR: "No apparent conflict in scene [scene_id]"
          - Suggestion: "Add opposition, stakes, or obstacles"
     b. **Flat sections:**
        - If 3+ consecutive scenes have tension_score < 0.3:
          - MAJOR: "Extended flat tension from [start_scene] to [end_scene]"
          - Suggestion: "Consider adding rising tension or micro-conflicts"
     c. **Tension curve mismatch:**
        - Compare actual curve to expected (from beat mapping)
        - If Midpoint scene has low tension: MAJOR
        - If resolution scene has peak tension: MINOR (unusual but not wrong)
        - If general shape deviates significantly: MINOR with note

   **Step 4: Generate Output**
   - Create JSON output:
     ```json
     {
       "checker": "tension-monitor",
       "timestamp": "[ISO 8601]",
       "scenes_checked": [count],
       "issues": [
         {
           "severity": "MAJOR|MINOR",
           "scene_id": "chXX_sYY",
           "type": "no_conflict|flat_section|curve_mismatch",
           "description": "[what's wrong]",
           "evidence": {
             "expected_tension": "[level]",
             "actual_tension": "[level]",
             "markers_found": [count],
             "tension_score": [number]
           },
           "suggestion": "[how to fix]"
         }
       ],
       "summary": {
         "critical": 0,
         "major": [count],
         "minor": [count],
         "passed": true|false,
         "tension_curve": [
           { "scene_id": "ch01_s01", "tension": "medium" },
           ...
         ]
       }
     }
     ```
   - Note: Tension issues are never CRITICAL (subjective)
   - Include tension_curve in summary for visualization

5. **Validation section**:
   - Verify all scenes analyzed
   - Verify tension curve built
   - Report: "Tension analysis complete: [count] scenes, [issues] issues"

6. **Examples section**:
   - Example: No conflict in scene (MAJOR)
   - Example: Flat section spanning 4 scenes (MAJOR)
   - Example: Tension curve showing proper rise and fall

**Key implementation notes:**
- Tension detection is heuristic, not definitive
- Conflict markers list should be comprehensive but not exhaustive
- Resolution scenes SHOULD have lower tension (not an error)
- Don't flag dialogue scenes as low-tension just because they're talky
- Consider scene type from beat sheet when evaluating
  </action>
  <verify>
Read claude_src/novel/agents/tension-monitor.md and confirm:
- YAML frontmatter with name, description, allowed-tools, version
- Role section explains tension monitoring job
- Execution has 4 steps: Load Tension Expectations, Analyze Scene Tension, Track Tension Curve, Generate Output
- Conflict marker detection documented
- Flat section detection (3+ consecutive)
- Tension curve included in summary
- No CRITICAL severity (tension is subjective)
- File is 200+ lines
  </verify>
  <done>
claude_src/novel/agents/tension-monitor.md exists with complete agent definition. Agent can load tension expectations, analyze scenes for conflict markers, track the tension curve, detect flat sections, and output structured JSON with tension analysis.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create /novel:check command</name>
  <files>claude_src/novel/commands/check.md</files>
  <action>
Create the /novel:check command that orchestrates all five quality checkers and generates a unified report.

**Command structure following existing patterns (write.md, outline.md):**

1. **Frontmatter** (YAML):
   - allowed-tools: [Read, Write, Bash, Glob, Grep, Task]
   - description: Run quality checks and generate consistency report

2. **Commands section**:
   - `/novel:check` - Run all quality checkers on draft scenes
   - `/novel:check --fix` - Show suggestions only (no auto-fix in v1)
   - `/novel:check [checker]` - Run specific checker only (canon, timeline, voice, pacing, tension)

3. **Execution section** with 6 steps:

   **Step 1: Validate Prerequisites**
   - Check state/story_state.json exists
   - Check at least one scene with status "drafted" exists in scene_index
   - Check canon files exist (style_guide.md, characters.md, world.md)
   - If no drafted scenes: ERROR "No scenes to check - run /novel:write first"
   - Count scenes to check: scenes where status == "drafted"

   **Step 2: Display Start Message**
   ```
   ========================================
   RUNNING QUALITY CHECKS
   ========================================

   Scenes to check: [count]
   Checkers: 5 (parallel execution)

   - Canon Checker: Verifying facts
   - Timeline Keeper: Checking chronology
   - Voice Coach: Analyzing style
   - Pacing Analyzer: Evaluating rhythm
   - Tension Monitor: Measuring conflict

   Running...
   ```

   **Step 3: Spawn Checkers in Parallel**
   - Use Task tool to spawn all five checkers simultaneously:
     ```
     [canon_result, timeline_result, voice_result, pacing_result, tension_result]
     = parallel_execute([
       spawn("claude_src/novel/agents/canon-checker.md"),
       spawn("claude_src/novel/agents/timeline-keeper.md"),
       spawn("claude_src/novel/agents/voice-coach.md"),
       spawn("claude_src/novel/agents/pacing-analyzer.md"),
       spawn("claude_src/novel/agents/tension-monitor.md")
     ])
     ```
   - If specific checker requested via `/novel:check [checker]`, only spawn that one
   - Collect JSON output from each checker

   **Step 4: Consolidate Results**
   - Merge all issues from all checkers into single issues array
   - Sort by severity: CRITICAL first, then MAJOR, then MINOR
   - Calculate totals:
     - total_critical = sum of all checkers' critical counts
     - total_major = sum of all checkers' major counts
     - total_minor = sum of all checkers' minor counts
   - Determine overall status:
     - Any CRITICAL: status = "CRITICAL ISSUES"
     - Any MAJOR (no CRITICAL): status = "NEEDS ATTENTION"
     - Only MINOR or none: status = "PASS"

   **Step 5: Save Reports**
   - Create timestamp directory: check_reports/YYYY-MM-DD_HH-MM/
   - Write individual checker JSONs:
     - canon_check.json
     - timeline_check.json
     - voice_check.json
     - pacing_check.json
     - tension_check.json
   - Generate summary.md using report format from RESEARCH.md:
     ```markdown
     # Quality Check Report

     **Generated:** [timestamp]
     **Scenes Checked:** [count] of [total]
     **Overall Status:** [PASS / NEEDS ATTENTION / CRITICAL ISSUES]

     ## Summary

     | Checker | Critical | Major | Minor | Status |
     |---------|----------|-------|-------|--------|
     | Canon Checker | 0 | 2 | 3 | ATTENTION |
     ...

     **Total:** [critical] critical, [major] major, [minor] minor

     ## Critical Issues (Must Fix)

     [List each critical issue with details]

     ## Major Issues (Should Fix)

     [List each major issue]

     ## Minor Issues (Nice to Fix)

     [List each minor issue - abbreviated]

     ## Recommendations

     [Top 3 prioritized action items]

     ## Next Steps

     - Fix critical issues before marking scenes as "checked"
     - Run `/novel:check` again after revisions
     - Once all critical/major issues resolved, scenes can be approved
     ```

   **Step 6: Display Report Summary**
   - Print summary table to user
   - List critical issues in full
   - Summarize major/minor counts
   - Show path to full report: "Full report: check_reports/[timestamp]/summary.md"
   - Provide recommendations

4. **Error Handling section**:
   - No drafted scenes: Guide to /novel:write
   - Checker agent fails: Report which checker failed, continue with others
   - Report directory creation fails: Fallback to console-only output
   - Git not available: Don't try to commit reports

5. **Validation section**:
   - Verify all requested checkers completed
   - Verify report files written
   - Report: "Quality check complete: [status] - [critical] critical, [major] major, [minor] minor"

6. **Examples section**:
   - Example: Running full check with issues found
   - Example: Running single checker
   - Example: Clean pass with no issues

**Key implementation notes:**
- Parallel execution is key for performance (5 agents = 5x faster than sequential)
- Each checker is independent - no inter-checker dependencies
- Report format matches RESEARCH.md Pattern 4 exactly
- Don't auto-fix anything - just report (v1 scope)
- Severity determines prominence in report, not order of checking
  </action>
  <verify>
Read claude_src/novel/commands/check.md and confirm:
- YAML frontmatter with allowed-tools including Task
- Commands section documents usage
- Step 3 spawns all 5 checkers in parallel
- Step 4 consolidates and sorts by severity
- Step 5 saves reports to check_reports/[timestamp]/
- Report format matches RESEARCH.md pattern
- Error handling for checker failures
- File is 200+ lines
  </verify>
  <done>
claude_src/novel/commands/check.md exists with complete command definition. Command validates prerequisites, spawns all five checkers in parallel, consolidates results, generates unified report with severity sorting, saves to check_reports/, and displays actionable summary.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create command symlink for discoverability</name>
  <files>.claude/commands/novel/check.md</files>
  <action>
Create symlink from .claude/commands/novel/check.md to claude_src/novel/commands/check.md for command discoverability.

**Steps:**
1. Ensure .claude/commands/novel/ directory exists
2. Create symlink: ln -sf ../../../claude_src/novel/commands/check.md .claude/commands/novel/check.md
3. Verify symlink is valid and points to correct target

This follows the pattern established in Phase 1 for /novel:init and /novel:status commands.
  </action>
  <verify>
Run: ls -la .claude/commands/novel/check.md
Confirm:
- Symlink exists
- Points to ../../../claude_src/novel/commands/check.md
- Symlink is not broken (file exists at target)
  </verify>
  <done>
.claude/commands/novel/check.md symlink exists and points to claude_src/novel/commands/check.md, making /novel:check discoverable by Claude Code.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete quality checking system with 5 checker agents and /novel:check command:
- Canon checker (fact consistency)
- Timeline keeper (chronological integrity)
- Voice coach (style adherence)
- Pacing analyzer (rhythm evaluation)
- Tension monitor (conflict tracking)
- /novel:check command (parallel orchestration)
  </what-built>
  <how-to-verify>
1. Review agent definitions in claude_src/novel/agents/:
   - canon-checker.md - detects character/world fact contradictions
   - timeline-keeper.md - validates chronology and dates
   - voice-coach.md - checks POV, tense, forbidden phrases
   - pacing-analyzer.md - evaluates word count deviations
   - tension-monitor.md - tracks conflict presence

2. Review command definition:
   - claude_src/novel/commands/check.md - orchestrates parallel execution

3. Verify command symlink:
   - .claude/commands/novel/check.md points to command definition

4. Confirm JSON output schemas match RESEARCH.md patterns

5. Confirm severity levels (CRITICAL/MAJOR/MINOR) are consistent across all checkers
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues to address</resume-signal>
</task>

</tasks>

<verification>
Check complete quality checking system:
1. All 5 checker agents follow established pattern (frontmatter + role + execution + validation)
2. All checkers output JSON with consistent schema (checker, timestamp, scenes_checked, issues, summary)
3. All checkers use severity levels (CRITICAL/MAJOR/MINOR) appropriately
4. /novel:check command spawns all checkers in parallel
5. Reports saved to check_reports/[timestamp]/ with summary.md and individual JSONs
6. Command symlink enables /novel:check discoverability
7. Overall status determination follows rules (any CRITICAL = CRITICAL ISSUES, etc.)
</verification>

<success_criteria>
- [ ] claude_src/novel/agents/tension-monitor.md exists with 200+ lines
- [ ] claude_src/novel/commands/check.md exists with 200+ lines
- [ ] .claude/commands/novel/check.md symlink exists and is valid
- [ ] Tension monitor validates: conflict presence, flat sections, tension curve
- [ ] /novel:check spawns all 5 checkers in parallel
- [ ] Results consolidated and sorted by severity
- [ ] Reports saved to check_reports/ directory
- [ ] Summary.md follows report format from RESEARCH.md
- [ ] Human verification checkpoint passed
</success_criteria>

<output>
After completion, create `.planning/phases/04-quality-checks/04-03-SUMMARY.md`
</output>
