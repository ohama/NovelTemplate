---
phase: 04-quality-checks
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - claude_src/novel/agents/canon-checker.md
  - claude_src/novel/agents/timeline-keeper.md
autonomous: true

must_haves:
  truths:
    - "Canon checker detects character fact contradictions with scene references"
    - "Canon checker validates world-building consistency"
    - "Timeline keeper flags chronological violations"
    - "Timeline keeper validates date/day-of-week matches"
    - "Both checkers output JSON with severity levels and fix suggestions"
  artifacts:
    - path: "claude_src/novel/agents/canon-checker.md"
      provides: "Canon consistency verification agent"
      min_lines: 200
      contains: "role.*execution.*validation"
    - path: "claude_src/novel/agents/timeline-keeper.md"
      provides: "Timeline consistency verification agent"
      min_lines: 200
      contains: "role.*execution.*validation"
  key_links:
    - from: "canon-checker agent"
      to: "canon/characters.md"
      via: "read character facts"
      pattern: "canon/characters"
    - from: "canon-checker agent"
      to: "draft/scenes/*.md"
      via: "cross-reference assertions"
      pattern: "draft/scenes"
    - from: "timeline-keeper agent"
      to: "state/timeline_state.json"
      via: "load event ordering"
      pattern: "timeline_state"
    - from: "timeline-keeper agent"
      to: "canon/timeline.md"
      via: "verify anchors"
      pattern: "canon/timeline"
---

<objective>
Build the novel-canon-checker and novel-timeline-keeper agents for detecting canon contradictions and timeline violations across draft scenes.

Purpose: These two checkers form the factual consistency layer of the quality system. Canon checker ensures character facts, world details, and object consistency match what's established in canon files. Timeline keeper ensures chronological coherence, date validity, and proper cause-effect ordering.

Output: Two complete agent definitions following the established pattern, ready to be spawned in parallel by /novel:check command.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-quality-checks/04-RESEARCH.md

# Existing agent patterns
@claude_src/novel/agents/scene-writer.md
@claude_src/novel/agents/plot-planner.md

# Skills and utilities
@claude_src/novel/utils/state-manager.md

# Schemas for state structure
@claude_src/novel/schemas/story_state.schema.json
@claude_src/novel/schemas/character_state.schema.json
@claude_src/novel/schemas/timeline_state.schema.json

# Canon templates for reference
@claude_src/novel/templates/characters.md
@claude_src/novel/templates/timeline.md
@claude_src/novel/templates/world.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create canon-checker agent definition</name>
  <files>claude_src/novel/agents/canon-checker.md</files>
  <action>
Create novel-canon-checker agent following the established agent pattern (YAML frontmatter + role + execution + validation).

**Agent structure:**

1. **Frontmatter** (YAML):
   - name: canon-checker
   - description: Detect canon contradictions and fact errors across draft scenes
   - allowed-tools: [Read, Glob, Grep]
   - version: 1.0

2. **Purpose section**:
   - Inputs: canon/characters.md, canon/world.md, canon/premise.md, state/character_state.json, draft/scenes/*.md
   - Outputs: JSON with issues array and summary
   - Role: Cross-reference draft assertions against established canon

3. **Role section** (in XML tags):
   - Job: Extract factual claims from canon, scan scenes for assertions, flag contradictions
   - What you check:
     - Character physical descriptions match canon
     - Character relationships match established facts
     - Location details are consistent
     - Object/item usage matches canon definitions
     - Character knowledge is appropriate for scene timing (no premature knowledge)
   - Principles:
     - CRITICAL severity for direct contradictions (character dead appears alive)
     - MAJOR severity for significant inconsistencies (wrong hair color)
     - MINOR severity for small details (slight description variation)
     - Always include scene_id, evidence (expected vs found), and fix suggestion

4. **Execution section** with 4 steps:

   **Step 1: Load Canon Facts**
   - Read canon/characters.md, extract:
     - Character names and physical descriptions
     - Character relationships
     - Personality traits
   - Read canon/world.md, extract:
     - Location names and descriptions
     - World rules and constraints
   - Read canon/premise.md, extract:
     - Story facts and core elements
   - Build canonical_facts map: { character: {...}, world: {...}, story: {...} }

   **Step 2: Build Character Knowledge Timeline**
   - From state/character_state.json, get character entries
   - From beats/outline.md, identify when characters learn key information
   - Build knowledge_timeline: { character_name: [{ learns: "fact", scene_id: "chXX_sYY" }] }
   - This enables detecting "character knows something before learning it"

   **Step 3: Scan Draft Scenes**
   - Use Glob to find draft/scenes/*.md files
   - For each scene file:
     - Parse YAML frontmatter for scene_id, pov, chapter
     - Extract prose content (skip frontmatter)
     - Identify factual assertions about characters (descriptions, dialogue claims)
     - Identify factual assertions about world (location descriptions, rules)
     - Cross-reference each assertion against canonical_facts
     - Check character references against knowledge_timeline for that scene
     - If contradiction found: Add to issues array with severity, evidence, suggestion

   **Step 4: Generate Output**
   - Create JSON output:
     ```json
     {
       "checker": "canon-checker",
       "timestamp": "[ISO 8601]",
       "scenes_checked": [count],
       "issues": [
         {
           "severity": "CRITICAL|MAJOR|MINOR",
           "scene_id": "chXX_sYY",
           "type": "character_fact|world_fact|character_knowledge",
           "description": "[what's wrong]",
           "evidence": {
             "expected": "[from canon]",
             "found": "[from scene]",
             "source": "[canon file path]"
           },
           "suggestion": "[how to fix]"
         }
       ],
       "summary": {
         "critical": [count],
         "major": [count],
         "minor": [count],
         "passed": true|false
       }
     }
     ```
   - passed is false if any CRITICAL issues exist

5. **Validation section**:
   - Verify all draft scenes were scanned
   - Verify output JSON is valid
   - Report: "Canon check complete: [total] issues ([critical] critical, [major] major, [minor] minor)"

6. **Examples section**:
   - Example issue: Character hair color changed (MAJOR)
   - Example issue: Character knows secret before learning it (CRITICAL)
   - Example of clean pass with no issues

**Key implementation notes:**
- Follow RESEARCH.md patterns (Canon Checker section)
- Don't flag stylistic choices as errors - only objective inconsistencies
- Character knowledge checking requires cross-referencing knowledge_timeline with scene ordering
- Include specific line/paragraph evidence when possible
  </action>
  <verify>
Read claude_src/novel/agents/canon-checker.md and confirm:
- YAML frontmatter with name, description, allowed-tools, version
- Role section explains canon verification job
- Execution has 4 steps: Load Canon Facts, Build Knowledge Timeline, Scan Draft Scenes, Generate Output
- Issue output follows JSON schema from RESEARCH.md
- Severity levels (CRITICAL/MAJOR/MINOR) are documented
- Examples show issue detection patterns
- File is 200+ lines
  </verify>
  <done>
claude_src/novel/agents/canon-checker.md exists with complete agent definition. Agent can extract facts from canon files, scan draft scenes for contradictions, detect premature character knowledge, and output structured JSON with severity-classified issues and fix suggestions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create timeline-keeper agent definition</name>
  <files>claude_src/novel/agents/timeline-keeper.md</files>
  <action>
Create novel-timeline-keeper agent following the established agent pattern.

**Agent structure:**

1. **Frontmatter** (YAML):
   - name: timeline-keeper
   - description: Detect timeline violations and chronological errors
   - allowed-tools: [Read, Glob, Grep]
   - version: 1.0

2. **Purpose section**:
   - Inputs: canon/timeline.md, state/timeline_state.json, beats/diary_plan.md (if diary format), draft/scenes/*.md
   - Outputs: JSON with issues array and summary
   - Role: Verify chronological consistency, date validity, cause-effect ordering

3. **Role section** (in XML tags):
   - Job: Build timeline from scene dates, verify ordering, check constraints
   - What you check:
     - Scene dates are chronologically ordered (no going backward unless flashback)
     - Events respect cause-effect ordering (can't reference event before it happens)
     - Dates match day-of-week (March 15, 2024 is actually a Friday)
     - Seasonal descriptions match dates (no snow in July unless hemisphere-appropriate)
     - Time spans are realistic (healing, travel, growth)
     - Timeline anchors from canon/timeline.md are respected
   - Principles:
     - CRITICAL severity for timeline reversals (impossible ordering)
     - CRITICAL severity for anchor violations (fixed dates changed)
     - MAJOR severity for unrealistic time spans
     - MINOR severity for day-of-week mismatches
     - Special handling for flashbacks/memories (marked in scene metadata)

4. **Execution section** with 4 steps:

   **Step 1: Load Timeline Constraints**
   - Read canon/timeline.md:
     - Extract anchor_dates (fixed historical events)
     - Extract constraints (event A must happen before event B)
   - Read state/timeline_state.json:
     - Get events array with dates and scene_ids
     - Get any user-defined constraints
   - If diary format, read beats/diary_plan.md:
     - Get date assignments for each entry
     - Get seasonal arc information

   **Step 2: Build Scene Timeline**
   - Use Glob to find draft/scenes/*.md files
   - For each scene, extract from YAML frontmatter:
     - scene_id
     - date (if present, especially for diary format)
     - Any timeline markers in content (references to specific dates)
   - Sort scenes by date (ascending)
   - Build timeline: [{ scene_id, date, chapter, scene }]

   **Step 3: Verify Chronology**
   - For each consecutive scene pair:
     - If scene_n.date > scene_n+1.date AND not marked as flashback:
       - CRITICAL: Timeline reversal detected
   - For each constraint in timeline_state.constraints:
     - Find scenes for "before" and "after" events
     - If scene(before).date >= scene(after).date:
       - CRITICAL: Constraint violated
   - For diary format, verify date/day-of-week matches:
     - Parse date header "March 15, 2024 - Friday"
     - Calculate actual day-of-week
     - If mismatch: MINOR issue
   - Check seasonal consistency:
     - Northern hemisphere: Dec-Feb = winter, Jun-Aug = summer
     - Flag "snow in July" type errors unless location justifies
   - Check time spans:
     - Major wounds healing too fast
     - Travel times unrealistic
     - If > 50% deviation from realistic: MAJOR

   **Step 4: Generate Output**
   - Create JSON output following same schema as canon-checker:
     ```json
     {
       "checker": "timeline-keeper",
       "timestamp": "[ISO 8601]",
       "scenes_checked": [count],
       "issues": [...],
       "summary": {
         "critical": [count],
         "major": [count],
         "minor": [count],
         "passed": true|false
       }
     }
   - Issue types: "timeline_reversal", "constraint_violation", "day_mismatch", "seasonal_error", "unrealistic_span"

5. **Validation section**:
   - Verify timeline was built from all scenes with dates
   - Verify constraint checking completed
   - Report: "Timeline check complete: [total] issues"

6. **Examples section**:
   - Example: Timeline reversal between ch03 and ch04
   - Example: Day-of-week mismatch in diary entry
   - Example: Anchor date violated

**Key implementation notes:**
- ISO 8601 date parsing (YYYY-MM-DD)
- Day-of-week calculation: Use Zeller's congruence or reference table
- Flashback detection: Check scene metadata or content markers
- Seasonal logic varies by hemisphere (world.md may specify location)
- Don't flag time gaps between scenes - only violations of constraints
  </action>
  <verify>
Read claude_src/novel/agents/timeline-keeper.md and confirm:
- YAML frontmatter with name, description, allowed-tools, version
- Role section explains timeline verification job
- Execution has 4 steps: Load Timeline Constraints, Build Scene Timeline, Verify Chronology, Generate Output
- Handles both diary format (with dates) and standard format
- Day-of-week validation documented
- Flashback/memory handling documented
- File is 200+ lines
  </verify>
  <done>
claude_src/novel/agents/timeline-keeper.md exists with complete agent definition. Agent can load timeline constraints, build scene chronology, detect ordering violations, verify date consistency for diary format, and output structured JSON with severity-classified issues.
  </done>
</task>

</tasks>

<verification>
Check both checker agents:
1. Both follow established agent pattern (frontmatter + role + execution + validation)
2. Both output JSON following the schema defined in RESEARCH.md
3. Both use severity levels (CRITICAL/MAJOR/MINOR)
4. Both include scene_id, evidence, and suggestion in each issue
5. Canon checker handles character facts, world facts, and knowledge timeline
6. Timeline keeper handles chronology, constraints, and date validation
7. Both are ready to be spawned in parallel by /novel:check
</verification>

<success_criteria>
- [ ] claude_src/novel/agents/canon-checker.md exists with 200+ lines
- [ ] claude_src/novel/agents/timeline-keeper.md exists with 200+ lines
- [ ] Both have YAML frontmatter with name, description, allowed-tools, version
- [ ] Both have role sections explaining their verification job
- [ ] Both have 4-step execution workflows
- [ ] Canon checker validates: character facts, world facts, knowledge timeline
- [ ] Timeline keeper validates: chronology, constraints, date/day matches
- [ ] Both output JSON with severity levels and fix suggestions
- [ ] Both are ready to be spawned by /novel:check command
</success_criteria>

<output>
After completion, create `.planning/phases/04-quality-checks/04-01-SUMMARY.md`
</output>
