---
phase: 05-revision-loop
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - claude_src/novel/commands/check.md
  - claude_src/novel/utils/state-manager.md
  - claude_src/novel/schemas/story_state.schema.json
autonomous: true

must_haves:
  truths:
    - "/novel:check spawns editor and quality gate after checkers complete"
    - "story_state.json tracks revision history with cycle number, check reports, decisions"
    - "Scene status updates to 'needs_revision' or 'approved' based on quality gate"
    - "Revision count increments with each check cycle"
  artifacts:
    - path: "claude_src/novel/commands/check.md"
      provides: "Extended check command with editor + quality gate pipeline"
      min_lines: 850
      contains: "novel-editor"
    - path: "claude_src/novel/schemas/story_state.schema.json"
      provides: "Extended schema with revision tracking fields"
      contains: "revision_history"
    - path: "claude_src/novel/utils/state-manager.md"
      provides: "Updated state manager with revision tracking documentation"
      contains: "revision_count"
  key_links:
    - from: "check.md Step 4"
      to: "novel-editor agent"
      via: "Task tool spawn after checkers"
      pattern: "Task.*novel-editor"
    - from: "check.md Step 5"
      to: "novel-quality-gate agent"
      via: "Task tool spawn after editor"
      pattern: "Task.*novel-quality-gate"
    - from: "check.md Step 6"
      to: "story_state.json"
      via: "Update scene status and revision_history"
      pattern: "revision_history.*append"
---

<objective>
Integrate editor and quality gate agents into /novel:check pipeline and extend state tracking to record revision cycles.

Purpose: Complete the three-stage revision loop (checkers → editor → quality gate) with full revision history tracking.

Output: Extended /novel:check command orchestrating 5 checkers + editor + quality gate, plus state schema supporting revision tracking.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-revision-loop/05-RESEARCH.md
@.planning/phases/05-revision-loop/05-01-SUMMARY.md
@claude_src/novel/commands/check.md
@claude_src/novel/schemas/story_state.schema.json
@claude_src/novel/utils/state-manager.md
@claude_src/novel/agents/novel-editor.md
@claude_src/novel/agents/novel-quality-gate.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend /novel:check command with editor + quality gate pipeline</name>
  <files>claude_src/novel/commands/check.md</files>
  <action>
Extend existing /novel:check command to add two new steps after checker consolidation.

Current flow (from Phase 4):
1. Validate prerequisites
2. Display start message
3. Spawn checkers (parallel)
4. Consolidate results
5. Save reports
6. Display summary

NEW extended flow:
1. Validate prerequisites (unchanged)
2. Display start message (unchanged)
3. Spawn checkers (parallel) (unchanged)
4. Consolidate results (unchanged)
5. Save reports (unchanged)
6. **NEW: Spawn novel-editor agent**
7. **NEW: Spawn novel-quality-gate agent**
8. **NEW: Update story_state.json with revision tracking**
9. Display summary (EXTENDED to include quality gate decision)

Implementation details for new steps:

**Step 6: Spawn novel-editor agent**
```markdown
After saving individual checker JSONs and summary.md:

1. Spawn novel-editor agent via Task tool:
   - Pass check report directory path as context
   - Editor reads all 5 checker JSONs from check_reports/[timestamp]/
   - Editor writes editorial_letter.md to same directory

2. Wait for editor completion

3. Verify editorial_letter.md exists:
   - If missing: Log warning, continue without editorial feedback
   - If exists: Log success

Error handling: Don't stop execution if editor fails - quality gate can run without editorial letter
```

**Step 7: Spawn novel-quality-gate agent**
```markdown
After editor completes:

1. Spawn novel-quality-gate agent via Task tool:
   - Pass check report directory path as context
   - Quality gate reads checker JSONs from check_reports/[timestamp]/
   - Quality gate writes quality_decision.json to same directory

2. Wait for quality gate completion

3. Parse quality_decision.json:
   - Extract overall_status, scene_decisions array
   - Store for state update and display

Error handling: If quality gate fails, fall back to basic pass/fail based on CRITICAL count
```

**Step 8: Update story_state.json with revision tracking**
```markdown
After quality gate completes:

1. Read current story_state.json

2. For each scene in quality_decision.scene_decisions:
   a. Find scene in story_state.scenes array by scene_id

   b. Update scene status:
      - If decision == "APPROVED": status = "approved"
      - If decision == "NEEDS_REVISION": status = "needs_revision"

   c. Increment revision_count (or initialize to 1 if missing)

   d. Append to revision_history array:
      {
        "cycle": revision_count,
        "timestamp": "[ISO 8601]",
        "check_report": "check_reports/[timestamp]",
        "issues_found": {
          "critical": [count from quality decision],
          "major": [count],
          "minor": [count]
        },
        "decision": "[APPROVED|NEEDS_REVISION]",
        "blocking_issues": [issue descriptions from quality decision],
        "editorial_focus": [extracted from editorial letter Must/Should items]
      }

   e. Update last_check timestamp

   f. If approved: Set approved_at timestamp

3. Write updated story_state.json

Error handling: If state update fails, log warning but don't stop - reports still saved
```

**Step 9: Extended display summary**

Update display to show quality gate results:

```markdown
Existing summary sections (Steps 6.1-6.6) PLUS:

New section after RECOMMENDATIONS:

========================================
QUALITY GATE DECISION
========================================

Overall Status: [overall_status from quality_decision.json]

Scenes Approved: [scenes_approved]
Scenes Need Revision: [scenes_need_revision]

[If any scenes need revision:]
Scenes requiring revision:
[for each scene in scene_decisions where decision == "NEEDS_REVISION":]
  - [scene_id]: [reason] ([blocking_issues count] blocking issues)

[If all scenes approved:]
All scenes passed quality gate.
Ready for publication.

========================================

Editorial feedback available at:
  check_reports/[timestamp]/editorial_letter.md

Quality gate decision:
  check_reports/[timestamp]/quality_decision.json

========================================
```

Update Commands section in frontmatter:
- Add note that /novel:check now includes editorial feedback + quality gate
- Mention revision tracking in state files

Update Examples section:
- Add example showing editorial letter + quality decision output
- Show revision history in state file example
  </action>
  <verify>grep -c "novel-editor" claude_src/novel/commands/check.md returns >0, grep -c "quality_decision" returns >0, file >850 lines</verify>
  <done>/novel:check command extended with editor + quality gate pipeline, state update logic, enhanced display showing approval decisions</done>
</task>

<task type="auto">
  <name>Task 2: Extend state schema and documentation for revision tracking</name>
  <files>
    claude_src/novel/schemas/story_state.schema.json
    claude_src/novel/utils/state-manager.md
  </files>
  <action>
Update story_state schema and state-manager documentation to support revision tracking.

**File 1: claude_src/novel/schemas/story_state.schema.json**

Add new fields to scene object in scenes array:

```json
{
  "scenes": {
    "type": "array",
    "items": {
      "type": "object",
      "properties": {
        // ... existing fields (scene_id, chapter, scene_number, title, etc.)

        // NEW: Revision tracking fields
        "status": {
          "type": "string",
          "enum": ["planned", "drafted", "needs_revision", "approved"],
          "description": "Scene lifecycle status - approved indicates passed quality gate"
        },
        "revision_count": {
          "type": "integer",
          "minimum": 0,
          "default": 0,
          "description": "Number of revision cycles (check runs) for this scene"
        },
        "revision_history": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "cycle": {
                "type": "integer",
                "description": "Revision cycle number (1, 2, 3...)"
              },
              "timestamp": {
                "type": "string",
                "format": "date-time",
                "description": "ISO 8601 timestamp of check run"
              },
              "check_report": {
                "type": "string",
                "description": "Path to check report directory"
              },
              "issues_found": {
                "type": "object",
                "properties": {
                  "critical": {"type": "integer"},
                  "major": {"type": "integer"},
                  "minor": {"type": "integer"}
                }
              },
              "decision": {
                "type": "string",
                "enum": ["needs_revision", "approved"]
              },
              "blocking_issues": {
                "type": "array",
                "items": {"type": "string"},
                "description": "List of blocking issue descriptions"
              },
              "editorial_focus": {
                "type": "array",
                "items": {"type": "string"},
                "description": "Priority areas from editorial letter"
              }
            },
            "required": ["cycle", "timestamp", "check_report", "decision"]
          },
          "default": []
        },
        "last_check": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp of most recent quality check"
        },
        "approved_at": {
          "type": "string",
          "format": "date-time",
          "description": "Timestamp when scene was approved by quality gate"
        }
      }
    }
  }
}
```

Update schema_version to 1.1 (increment from 1.0).

**File 2: claude_src/novel/utils/state-manager.md**

Add new section documenting revision tracking:

```markdown
## Revision Tracking

The state manager now tracks quality check cycles and approval status for each scene.

### Scene Status Lifecycle

```
planned → drafted → needs_revision ⇄ approved
                         ↑______________|
                         (revision cycle)
```

Status values:
- `planned`: Scene exists in beat plan but not yet drafted
- `drafted`: Scene prose written, not yet checked
- `needs_revision`: Quality gate rejected scene, fixes needed
- `approved`: Quality gate approved scene, ready for publication

### Revision History

Each quality check run appends a revision cycle entry:

```json
{
  "cycle": 1,
  "timestamp": "2026-02-24T14:30:00Z",
  "check_report": "check_reports/2026-02-24_14-30",
  "issues_found": { "critical": 0, "major": 2, "minor": 1 },
  "decision": "needs_revision",
  "blocking_issues": ["voice inconsistency", "pacing too slow"],
  "editorial_focus": ["voice", "pacing"]
}
```

### Accessing Revision Data

**Get scene status:**
```
scene.status  // "approved", "needs_revision", etc.
```

**Get revision count:**
```
scene.revision_count  // Number of check cycles
```

**Get latest check result:**
```
scene.revision_history[-1]  // Most recent cycle
```

**Check if scene approved:**
```
scene.status == "approved" && scene.approved_at != null
```

### State Updates

Quality checks automatically update:
- `status` based on quality gate decision
- `revision_count` incremented each check
- `revision_history` appended with cycle data
- `last_check` updated to current timestamp
- `approved_at` set when first approved

No manual state updates needed - /novel:check handles all tracking.
```

Add revision tracking to the "State Files Overview" section.
  </action>
  <verify>grep -c "revision_history" claude_src/novel/schemas/story_state.schema.json returns >0, grep -c "Revision Tracking" claude_src/novel/utils/state-manager.md returns >0</verify>
  <done>story_state.schema.json extended with revision fields (status enum, revision_count, revision_history array), state-manager.md documents revision tracking usage</done>
</task>

</tasks>

<verification>
After task completion:
- [ ] /novel:check command includes Steps 6-9 (editor, quality gate, state update, extended display)
- [ ] story_state.schema.json has revision_history array definition
- [ ] state-manager.md documents revision tracking lifecycle
- [ ] Command references both agents via Task tool spawn
- [ ] State update logic handles approved vs needs_revision status
- [ ] Display shows quality gate decision and scene-level approval status
</verification>

<success_criteria>
- /novel:check orchestrates complete pipeline: checkers → consolidate → editor → quality gate → state update
- story_state.json schema supports revision_history tracking
- Scene status lifecycle includes "needs_revision" and "approved" states
- Console output shows quality gate decision and scenes needing revision
- Ready for end-to-end verification in Plan 05-03
</success_criteria>

<output>
After completion, create `.planning/phases/05-revision-loop/05-02-SUMMARY.md`
</output>
